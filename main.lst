   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 120               	.global	uart_tx
 122               	uart_tx:
 123               		.stabd	46,0,0
   1:main.c        **** #include <avr/io.h>
   2:main.c        **** #include <avr/interrupt.h>
   3:main.c        **** #include <stdint.h>
   4:main.c        **** #include <avr/pgmspace.h>
   5:main.c        **** #include <stdlib.h>
   6:main.c        **** 
   7:main.c        **** #define ARRLEN(x)             (sizeof(x) / sizeof(*x))
   8:main.c        **** 
   9:main.c        **** /* RC5 */
  10:main.c        **** #define RC5_IN                PIND
  11:main.c        **** #define RC5_PIN              7
  12:main.c        **** #define RC5_TIME      1.778e-3 /* 1.778 _ms */
  13:main.c        **** #define RC5_PULSE_MIN         (uint8_t)(F_CPU / 512 * RC5_TIME * 0.4 + 0.5)
  14:main.c        **** #define RC5_PULSE_1_2         (uint8_t)(F_CPU / 512 * RC5_TIME * 0.8 + 0.5)
  15:main.c        **** #define RC5_PULSE_MAX         (uint8_t)(F_CPU / 512 * RC5_TIME * 1.2 + 0.5)
  16:main.c        **** 
  17:main.c        **** static volatile uint16_t rc5_data;
  18:main.c        **** 
  19:main.c        **** 
  20:main.c        **** /* UART */
  21:main.c        **** #define UART_BAUD         9600
  22:main.c        **** #define UART_PRESCALER        (uint16_t)(F_CPU / UART_BAUD / 16 - 0.5)
  23:main.c        **** 
  24:main.c        **** 
  25:main.c        **** void uart_tx(char c)
  26:main.c        **** {
 125               	.LM0:
 126               	.LFBB1:
 127               	/* prologue: function */
 128               	/* frame size = 0 */
 129               	/* stack size = 0 */
 130               	.L__stack_usage = 0
 131               	.L2:
  27:main.c        **** 	while(!(UCSR0A & (1 << UDRE0))) ;
 133               	.LM1:
 134 0000 9091 C000 		lds r25,192
 136               	.LM2:
 137 0004 95FF      		sbrs r25,5
 138 0006 00C0      		rjmp .L2
  28:main.c        **** 	UDR0 = c;
 140               	.LM3:
 141 0008 8093 C600 		sts 198,r24
 142               	/* epilogue start */
  29:main.c        **** }
 144               	.LM4:
 145 000c 0895      		ret
 147               	.Lscope1:
 149               		.stabd	78,0,0
 151               	.global	uart_tx_s
 153               	uart_tx_s:
 154               		.stabd	46,0,0
  30:main.c        **** 
  31:main.c        **** void uart_tx_s(const char *s)
  32:main.c        **** {
 156               	.LM5:
 157               	.LFBB2:
 158 000e CF93      		push r28
 159 0010 DF93      		push r29
 160               	/* prologue: function */
 161               	/* frame size = 0 */
 162               	/* stack size = 2 */
 163               	.L__stack_usage = 2
 164               	.L6:
  33:main.c        **** 	register char c;
  34:main.c        **** 	while((c = *s++))
 166               	.LM6:
 167 0012 EC01      		movw r28,r24
 169               	.LM7:
 170 0014 8991      		ld r24,Y+
 172               	.LM8:
 173 0016 8111      		cpse r24,__zero_reg__
 174 0018 00C0      		rjmp .L7
 175               	/* epilogue start */
  35:main.c        **** 	{
  36:main.c        **** 		uart_tx(c);
  37:main.c        **** 	}
  38:main.c        **** }
 177               	.LM9:
 178 001a DF91      		pop r29
 179 001c CF91      		pop r28
 180 001e 0895      		ret
 181               	.L7:
  36:main.c        **** 	}
 183               	.LM10:
 184 0020 0E94 0000 		call uart_tx
  34:main.c        **** 	{
 186               	.LM11:
 187 0024 CE01      		movw r24,r28
 188 0026 00C0      		rjmp .L6
 193               	.Lscope2:
 195               		.stabd	78,0,0
 198               	.global	uart_tx_P
 200               	uart_tx_P:
 201               		.stabd	46,0,0
  39:main.c        **** 
  40:main.c        **** void uart_tx_P(const char *s)
  41:main.c        **** {
 203               	.LM12:
 204               	.LFBB3:
 205 0028 CF93      		push r28
 206 002a DF93      		push r29
 207               	/* prologue: function */
 208               	/* frame size = 0 */
 209               	/* stack size = 2 */
 210               	.L__stack_usage = 2
 211 002c EC01      		movw r28,r24
 212               	.L9:
 213               	.LBB7:
  42:main.c        **** 	register char c;
  43:main.c        **** 	while((c = pgm_read_byte(s++)))
 215               	.LM13:
 216 002e FE01      		movw r30,r28
 217               	/* #APP */
 218               	 ;  43 "main.c" 1
 219 0030 8491      		lpm r24, Z
 220               		
 221               	 ;  0 "" 2
 222               	/* #NOAPP */
 223 0032 2196      		adiw r28,1
 224               	.LBE7:
 226               	.LM14:
 227 0034 8111      		cpse r24,__zero_reg__
 228 0036 00C0      		rjmp .L10
 229               	/* epilogue start */
  44:main.c        **** 	{
  45:main.c        **** 		uart_tx(c);
  46:main.c        **** 	}
  47:main.c        **** }
 231               	.LM15:
 232 0038 DF91      		pop r29
 233 003a CF91      		pop r28
 234 003c 0895      		ret
 235               	.L10:
  45:main.c        **** 	}
 237               	.LM16:
 238 003e 0E94 0000 		call uart_tx
 239 0042 00C0      		rjmp .L9
 244               	.Lscope3:
 246               		.stabd	78,0,0
 247               		.section	.rodata.str1.1,"aMS",@progbits,1
 248               	.LC0:
 249 0000 0D0A 00   		.string	"\r\n"
 250               		.section	.text.startup,"ax",@progbits
 252               	.global	main
 254               	main:
 255               		.stabd	46,0,0
  48:main.c        **** 
  49:main.c        **** int main(void)
  50:main.c        **** {
 257               	.LM17:
 258               	.LFBB4:
 259 0000 CDB7      		in r28,__SP_L__
 260 0002 DEB7      		in r29,__SP_H__
 261 0004 2897      		sbiw r28,8
 262 0006 0FB6      		in __tmp_reg__,__SREG__
 263 0008 F894      		cli
 264 000a DEBF      		out __SP_H__,r29
 265 000c 0FBE      		out __SREG__,__tmp_reg__
 266 000e CDBF      		out __SP_L__,r28
 267               	/* prologue: function */
 268               	/* frame size = 8 */
 269               	/* stack size = 8 */
 270               	.L__stack_usage = 8
  51:main.c        **** 	char s[8];
  52:main.c        **** 	uint16_t i;
  53:main.c        **** 
  54:main.c        **** 	/* RC5 Timer */
  55:main.c        **** 	TCCR2B = (1 << CS22) | (1 << CS21);
 272               	.LM18:
 273 0010 86E0      		ldi r24,lo8(6)
 274 0012 8093 B100 		sts 177,r24
  56:main.c        **** 	TIMSK2 = (1 << TOIE2);
 276               	.LM19:
 277 0016 91E0      		ldi r25,lo8(1)
 278 0018 9093 7000 		sts 112,r25
  57:main.c        **** 
  58:main.c        **** 	/* UART Receiver */
  59:main.c        **** 	UBRR0 = UART_PRESCALER;
 280               	.LM20:
 281 001c 27E6      		ldi r18,lo8(103)
 282 001e 30E0      		ldi r19,0
 283 0020 3093 C500 		sts 196+1,r19
 284 0024 2093 C400 		sts 196,r18
  60:main.c        **** 	UCSR0A = 0;
 286               	.LM21:
 287 0028 1092 C000 		sts 192,__zero_reg__
  61:main.c        **** 	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
 289               	.LM22:
 290 002c 8093 C200 		sts 194,r24
  62:main.c        **** 	UCSR0B = (1 << RXEN0) | (1 << TXEN0);
 292               	.LM23:
 293 0030 88E1      		ldi r24,lo8(24)
 294 0032 8093 C100 		sts 193,r24
  63:main.c        **** 
  64:main.c        **** 	sei();
 296               	.LM24:
 297               	/* #APP */
 298               	 ;  64 "main.c" 1
 299 0036 7894      		sei
 300               	 ;  0 "" 2
 301               	/* #NOAPP */
 302               	.L12:
  65:main.c        **** 
  66:main.c        **** 	for(;;)
  67:main.c        **** 	{
  68:main.c        **** 		cli();
 304               	.LM25:
 305               	/* #APP */
 306               	 ;  68 "main.c" 1
 307 0038 F894      		cli
 308               	 ;  0 "" 2
  69:main.c        **** 		i = rc5_data;
 310               	.LM26:
 311               	/* #NOAPP */
 312 003a 2091 0000 		lds r18,rc5_data
 313 003e 3091 0000 		lds r19,rc5_data+1
  70:main.c        **** 		rc5_data = 0;
 315               	.LM27:
 316 0042 1092 0000 		sts rc5_data+1,__zero_reg__
 317 0046 1092 0000 		sts rc5_data,__zero_reg__
  71:main.c        **** 		sei();
 319               	.LM28:
 320               	/* #APP */
 321               	 ;  71 "main.c" 1
 322 004a 7894      		sei
 323               	 ;  0 "" 2
  72:main.c        **** 
  73:main.c        **** 		if(i)
 325               	.LM29:
 326               	/* #NOAPP */
 327 004c 2115      		cp r18,__zero_reg__
 328 004e 3105      		cpc r19,__zero_reg__
 329 0050 01F0      		breq .L12
  74:main.c        **** 		{
  75:main.c        **** 			i = (i & 0x3F) | (~i >> 7 & 0x40);
 331               	.LM30:
 332 0052 8901      		movw r16,r18
 333 0054 0F73      		andi r16,63
 334 0056 1127      		clr r17
 336               	.LM31:
 337 0058 2095      		com r18
 338 005a 3095      		com r19
 340               	.LM32:
 341 005c 220F      		lsl r18
 342 005e 232F      		mov r18,r19
 343 0060 221F      		rol r18
 344 0062 330B      		sbc r19,r19
 345 0064 3195      		neg r19
 347               	.LM33:
 348 0066 2074      		andi r18,64
 349 0068 3327      		clr r19
 351               	.LM34:
 352 006a 022B      		or r16,r18
 353 006c 132B      		or r17,r19
  76:main.c        **** 
  77:main.c        **** 			uart_tx_P(PSTR("KEY: "));
 355               	.LM35:
 356 006e 80E0      		ldi r24,lo8(__c.1364)
 357 0070 90E0      		ldi r25,hi8(__c.1364)
 358 0072 0E94 0000 		call uart_tx_P
 359               	.LBB8:
 360               	.LBB9:
 362               	.Ltext1:
   1:/usr/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/avr/include/stdlib.h **** 
   4:/usr/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/avr/include/stdlib.h **** 
   7:/usr/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/avr/include/stdlib.h **** 
   9:/usr/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/avr/include/stdlib.h **** 
  12:/usr/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/avr/include/stdlib.h **** 
  15:/usr/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/avr/include/stdlib.h ****      distribution.
  19:/usr/avr/include/stdlib.h **** 
  20:/usr/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/avr/include/stdlib.h **** 
  24:/usr/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/avr/include/stdlib.h **** 
  36:/usr/avr/include/stdlib.h ****   $Id: stdlib.h 2503 2016-02-07 22:59:47Z joerg_wunsch $
  37:/usr/avr/include/stdlib.h **** */
  38:/usr/avr/include/stdlib.h **** 
  39:/usr/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/avr/include/stdlib.h **** 
  42:/usr/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/avr/include/stdlib.h **** 
  44:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/avr/include/stdlib.h **** 
  50:/usr/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/avr/include/stdlib.h **** #endif
  53:/usr/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/avr/include/stdlib.h **** 
  55:/usr/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/avr/include/stdlib.h **** extern "C" {
  57:/usr/avr/include/stdlib.h **** #endif
  58:/usr/avr/include/stdlib.h **** 
  59:/usr/avr/include/stdlib.h **** /** \file */
  60:/usr/avr/include/stdlib.h **** 
  61:/usr/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/avr/include/stdlib.h **** 
  64:/usr/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/avr/include/stdlib.h **** */
  67:/usr/avr/include/stdlib.h **** 
  68:/usr/avr/include/stdlib.h **** /*@{*/
  69:/usr/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/avr/include/stdlib.h **** typedef struct {
  71:/usr/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/avr/include/stdlib.h **** } div_t;
  74:/usr/avr/include/stdlib.h **** 
  75:/usr/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/avr/include/stdlib.h **** typedef struct {
  77:/usr/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/avr/include/stdlib.h **** 
  81:/usr/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/avr/include/stdlib.h **** 
  84:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/avr/include/stdlib.h **** 
  86:/usr/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/avr/include/stdlib.h **** #endif
  89:/usr/avr/include/stdlib.h **** 
  90:/usr/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/avr/include/stdlib.h **** #endif
  93:/usr/avr/include/stdlib.h **** 
  94:/usr/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/avr/include/stdlib.h **** #endif
  97:/usr/avr/include/stdlib.h **** 
  98:/usr/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/avr/include/stdlib.h **** #endif
 101:/usr/avr/include/stdlib.h **** 
 102:/usr/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/avr/include/stdlib.h **** # else
 106:/usr/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/avr/include/stdlib.h **** # endif
 108:/usr/avr/include/stdlib.h **** #endif
 109:/usr/avr/include/stdlib.h **** 
 110:/usr/avr/include/stdlib.h **** #endif
 111:/usr/avr/include/stdlib.h **** 
 112:/usr/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/avr/include/stdlib.h **** 
 118:/usr/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/avr/include/stdlib.h **** */
 121:/usr/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/avr/include/stdlib.h **** #endif
 125:/usr/avr/include/stdlib.h **** 
 126:/usr/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/avr/include/stdlib.h ****     \c i.
 128:/usr/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/avr/include/stdlib.h **** */
 130:/usr/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/avr/include/stdlib.h **** #endif
 134:/usr/avr/include/stdlib.h **** 
 135:/usr/avr/include/stdlib.h **** /**
 136:/usr/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/avr/include/stdlib.h **** 
 141:/usr/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/avr/include/stdlib.h **** 
 149:/usr/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/avr/include/stdlib.h **** */
 153:/usr/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/avr/include/stdlib.h **** 
 156:/usr/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/avr/include/stdlib.h **** /**
 158:/usr/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/avr/include/stdlib.h **** */
 162:/usr/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/avr/include/stdlib.h **** /**
 164:/usr/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/avr/include/stdlib.h **** */
 168:/usr/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/avr/include/stdlib.h **** 
 170:/usr/avr/include/stdlib.h **** /**
 171:/usr/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/avr/include/stdlib.h ****      quicksort.
 173:/usr/avr/include/stdlib.h **** 
 174:/usr/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/avr/include/stdlib.h **** 
 181:/usr/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/avr/include/stdlib.h **** */
 185:/usr/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/avr/include/stdlib.h **** 
 188:/usr/avr/include/stdlib.h **** /**
 189:/usr/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/avr/include/stdlib.h **** 
 193:/usr/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/avr/include/stdlib.h **** 
 200:/usr/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/avr/include/stdlib.h **** 
 206:/usr/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/avr/include/stdlib.h **** 
 212:/usr/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/avr/include/stdlib.h **** */
 218:/usr/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/avr/include/stdlib.h **** 
 220:/usr/avr/include/stdlib.h **** /**
 221:/usr/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/avr/include/stdlib.h ****     special value 0.
 225:/usr/avr/include/stdlib.h **** 
 226:/usr/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/avr/include/stdlib.h **** 
 233:/usr/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/avr/include/stdlib.h **** 
 239:/usr/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/avr/include/stdlib.h **** 
 245:/usr/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/avr/include/stdlib.h **** */
 252:/usr/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/avr/include/stdlib.h **** 
 254:/usr/avr/include/stdlib.h **** /**
 255:/usr/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/avr/include/stdlib.h **** 
 258:/usr/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/avr/include/stdlib.h **** 
 260:/usr/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/avr/include/stdlib.h **** */
 264:/usr/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/avr/include/stdlib.h **** 
 266:/usr/avr/include/stdlib.h **** /**
 267:/usr/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/avr/include/stdlib.h **** 
 270:/usr/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/avr/include/stdlib.h **** 
 272:/usr/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/avr/include/stdlib.h **** */
 276:/usr/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/avr/include/stdlib.h **** 
 278:/usr/avr/include/stdlib.h **** /**
 279:/usr/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/avr/include/stdlib.h **** 
 285:/usr/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/avr/include/stdlib.h ****    execution.
 287:/usr/avr/include/stdlib.h **** */
 288:/usr/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/avr/include/stdlib.h **** 
 290:/usr/avr/include/stdlib.h **** /**
 291:/usr/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/avr/include/stdlib.h **** 
 294:/usr/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/avr/include/stdlib.h ****    zero bytes.
 296:/usr/avr/include/stdlib.h **** 
 297:/usr/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/avr/include/stdlib.h ****    details.
 299:/usr/avr/include/stdlib.h **** */
 300:/usr/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/avr/include/stdlib.h **** 
 302:/usr/avr/include/stdlib.h **** /**
 303:/usr/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/avr/include/stdlib.h **** */
 307:/usr/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/avr/include/stdlib.h **** 
 309:/usr/avr/include/stdlib.h **** /**
 310:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/avr/include/stdlib.h **** */
 312:/usr/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/avr/include/stdlib.h **** 
 314:/usr/avr/include/stdlib.h **** /**
 315:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/avr/include/stdlib.h **** */
 317:/usr/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/avr/include/stdlib.h **** 
 319:/usr/avr/include/stdlib.h **** /**
 320:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/avr/include/stdlib.h **** */
 322:/usr/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/avr/include/stdlib.h **** 
 324:/usr/avr/include/stdlib.h **** /**
 325:/usr/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/avr/include/stdlib.h **** */
 329:/usr/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/avr/include/stdlib.h **** 
 331:/usr/avr/include/stdlib.h **** /**
 332:/usr/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/avr/include/stdlib.h ****    region.
 337:/usr/avr/include/stdlib.h **** 
 338:/usr/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/avr/include/stdlib.h **** 
 342:/usr/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/avr/include/stdlib.h **** 
 345:/usr/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/avr/include/stdlib.h **** */
 348:/usr/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/avr/include/stdlib.h **** 
 350:/usr/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/avr/include/stdlib.h **** 
 352:/usr/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 353:/usr/avr/include/stdlib.h **** 
 354:/usr/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 355:/usr/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 356:/usr/avr/include/stdlib.h **** 
 357:/usr/avr/include/stdlib.h **** /**
 358:/usr/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 359:/usr/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 360:/usr/avr/include/stdlib.h **** 
 361:/usr/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 362:/usr/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 363:/usr/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 364:/usr/avr/include/stdlib.h **** 
 365:/usr/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 366:/usr/avr/include/stdlib.h ****      a value of 1.
 367:/usr/avr/include/stdlib.h **** 
 368:/usr/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 369:/usr/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 370:/usr/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 371:/usr/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 372:/usr/avr/include/stdlib.h ****      32-bit precision.
 373:/usr/avr/include/stdlib.h **** */
 374:/usr/avr/include/stdlib.h **** extern int rand(void);
 375:/usr/avr/include/stdlib.h **** /**
 376:/usr/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 377:/usr/avr/include/stdlib.h **** */
 378:/usr/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 379:/usr/avr/include/stdlib.h **** 
 380:/usr/avr/include/stdlib.h **** /**
 381:/usr/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 382:/usr/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 383:/usr/avr/include/stdlib.h ****    so the function becomes re-entrant.
 384:/usr/avr/include/stdlib.h **** */
 385:/usr/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 386:/usr/avr/include/stdlib.h **** /*@}*/
 387:/usr/avr/include/stdlib.h **** 
 388:/usr/avr/include/stdlib.h **** /*@{*/
 389:/usr/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 390:/usr/avr/include/stdlib.h ****  \ingroup avr_stdlib
 391:/usr/avr/include/stdlib.h **** */
 392:/usr/avr/include/stdlib.h **** /**
 393:/usr/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 394:/usr/avr/include/stdlib.h **** 
 395:/usr/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 396:/usr/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 397:/usr/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 398:/usr/avr/include/stdlib.h **** 
 399:/usr/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 400:/usr/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 401:/usr/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 402:/usr/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 403:/usr/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 404:/usr/avr/include/stdlib.h **** 
 405:/usr/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 406:/usr/avr/include/stdlib.h **** 
 407:/usr/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 408:/usr/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 409:/usr/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 410:/usr/avr/include/stdlib.h ****    \c 'a'.
 411:/usr/avr/include/stdlib.h ****     
 412:/usr/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 413:/usr/avr/include/stdlib.h **** 
 414:/usr/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 415:/usr/avr/include/stdlib.h **** */
 416:/usr/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 417:/usr/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 418:/usr/avr/include/stdlib.h **** #else
 419:/usr/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 420:/usr/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 421:/usr/avr/include/stdlib.h **** {
 422:/usr/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 423:/usr/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 424:/usr/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 425:/usr/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 426:/usr/avr/include/stdlib.h **** 	*__s = 0;
 427:/usr/avr/include/stdlib.h **** 	return __s;
 428:/usr/avr/include/stdlib.h ****     } else {
 429:/usr/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 430:/usr/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 364               	.LM36:
 365 0076 4AE0      		ldi r20,lo8(10)
 366 0078 BE01      		movw r22,r28
 367 007a 6F5F      		subi r22,-1
 368 007c 7F4F      		sbci r23,-1
 369 007e C801      		movw r24,r16
 370 0080 0E94 0000 		call __itoa_ncheck
 371               	.LBE9:
 372               	.LBE8:
 374               	.Ltext2:
  78:main.c        **** 			uart_tx_s(itoa(i, s, 10));
 376               	.LM37:
 377 0084 0E94 0000 		call uart_tx_s
  79:main.c        **** 			uart_tx_s("\r\n");
 379               	.LM38:
 380 0088 80E0      		ldi r24,lo8(.LC0)
 381 008a 90E0      		ldi r25,hi8(.LC0)
 382 008c 0E94 0000 		call uart_tx_s
 383 0090 00C0      		rjmp .L12
 388               	.Lscope4:
 390               		.stabd	78,0,0
 391               		.text
 393               	.global	__vector_9
 395               	__vector_9:
 396               		.stabd	46,0,0
  80:main.c        **** 		}
  81:main.c        **** 	}
  82:main.c        **** 
  83:main.c        **** 	return 0;
  84:main.c        **** }
  85:main.c        **** 
  86:main.c        **** /* RC5 */
  87:main.c        **** ISR(TIMER2_OVF_vect)
  88:main.c        **** {
 398               	.LM39:
 399               	.LFBB5:
 400 0044 1F92 1FB6 		__gcc_isr 1
 400      1F92 1124 
 400      2F93 
 401 004e 3F93      		push r19
 402 0050 8F93      		push r24
 403 0052 9F93      		push r25
 404               	/* prologue: Signal */
 405               	/* frame size = 0 */
 406               	/* stack size = 3...7 */
 407               	.L__stack_usage = 3 + __gcc_isr.n_pushed
  89:main.c        **** 	static uint16_t rc5_tmp;
  90:main.c        **** 	static uint8_t rc5_bit, rc5_time;
  91:main.c        **** 	TCNT2 = -2;
 409               	.LM40:
 410 0054 8EEF      		ldi r24,lo8(-2)
 411 0056 8093 B200 		sts 178,r24
  92:main.c        **** 
  93:main.c        **** 	if(++rc5_time > RC5_PULSE_MAX)
 413               	.LM41:
 414 005a 8091 0000 		lds r24,rc5_time.1374
 415 005e 8F5F      		subi r24,lo8(-(1))
 417               	.LM42:
 418 0060 8093 0000 		sts rc5_time.1374,r24
 419 0064 8434      		cpi r24,lo8(68)
 420 0066 00F0      		brlo .L17
  94:main.c        **** 	{
  95:main.c        **** 		if(!(rc5_tmp & 0x4000) && rc5_tmp & 0x2000)
 422               	.LM43:
 423 0068 2091 0000 		lds r18,rc5_tmp.1372
 424 006c 3091 0000 		lds r19,rc5_tmp.1372+1
 426               	.LM44:
 427 0070 36FD      		sbrc r19,6
 428 0072 00C0      		rjmp .L18
 430               	.LM45:
 431 0074 35FF      		sbrs r19,5
 432 0076 00C0      		rjmp .L18
  96:main.c        **** 		{
  97:main.c        **** 			rc5_data = rc5_tmp;
 434               	.LM46:
 435 0078 3093 0000 		sts rc5_data+1,r19
 436 007c 2093 0000 		sts rc5_data,r18
 437               	.L18:
  98:main.c        **** 		}
  99:main.c        **** 
 100:main.c        **** 		rc5_tmp = 0;
 439               	.LM47:
 440 0080 1092 0000 		sts rc5_tmp.1372+1,__zero_reg__
 441 0084 1092 0000 		sts rc5_tmp.1372,__zero_reg__
 442               	.L17:
 101:main.c        **** 	}
 102:main.c        **** 
 103:main.c        **** 	if((rc5_bit ^ RC5_IN) & (1 << RC5_PIN))
 444               	.LM48:
 445 0088 29B1      		in r18,0x9
 447               	.LM49:
 448 008a 9091 0000 		lds r25,rc5_bit.1373
 449 008e 2927      		eor r18,r25
 451               	.LM50:
 452 0090 27FF      		sbrs r18,7
 453 0092 00C0      		rjmp .L16
 104:main.c        **** 	{
 105:main.c        **** 		rc5_bit = ~rc5_bit;
 455               	.LM51:
 456 0094 9095      		com r25
 457 0096 9093 0000 		sts rc5_bit.1373,r25
 106:main.c        **** 		if(rc5_time < RC5_PULSE_MIN)
 459               	.LM52:
 460 009a 8631      		cpi r24,lo8(22)
 461 009c 00F4      		brsh .L21
 107:main.c        **** 		{
 108:main.c        **** 			rc5_tmp = 0;
 463               	.LM53:
 464 009e 1092 0000 		sts rc5_tmp.1372+1,__zero_reg__
 465 00a2 1092 0000 		sts rc5_tmp.1372,__zero_reg__
 466               	.L21:
 109:main.c        **** 		}
 110:main.c        **** 
 111:main.c        **** 		if(!rc5_tmp || rc5_time > RC5_PULSE_1_2)
 468               	.LM54:
 469 00a6 2091 0000 		lds r18,rc5_tmp.1372
 470 00aa 3091 0000 		lds r19,rc5_tmp.1372+1
 472               	.LM55:
 473 00ae 2115      		cp r18,__zero_reg__
 474 00b0 3105      		cpc r19,__zero_reg__
 475 00b2 01F0      		breq .L22
 477               	.LM56:
 478 00b4 8D32      		cpi r24,lo8(45)
 479 00b6 00F0      		brlo .L16
 112:main.c        **** 		{
 113:main.c        **** 			if(!(rc5_tmp & 0x4000))
 481               	.LM57:
 482 00b8 36FD      		sbrc r19,6
 483 00ba 00C0      		rjmp .L24
 484               	.L22:
 114:main.c        **** 			{
 115:main.c        **** 				rc5_tmp <<= 1;
 486               	.LM58:
 487 00bc 220F      		lsl r18
 488 00be 331F      		rol r19
 489 00c0 3093 0000 		sts rc5_tmp.1372+1,r19
 490 00c4 2093 0000 		sts rc5_tmp.1372,r18
 491               	.L24:
 116:main.c        **** 			}
 117:main.c        **** 
 118:main.c        **** 			if(!(rc5_bit & (1 << RC5_PIN)))
 493               	.LM59:
 494 00c8 97FD      		sbrc r25,7
 495 00ca 00C0      		rjmp .L25
 119:main.c        **** 			{
 120:main.c        **** 				rc5_tmp |= 1;
 497               	.LM60:
 498 00cc 8091 0000 		lds r24,rc5_tmp.1372
 499 00d0 9091 0000 		lds r25,rc5_tmp.1372+1
 500 00d4 8160      		ori r24,1
 501 00d6 9093 0000 		sts rc5_tmp.1372+1,r25
 502 00da 8093 0000 		sts rc5_tmp.1372,r24
 503               	.L25:
 121:main.c        **** 			}
 122:main.c        **** 
 123:main.c        **** 			rc5_time = 0;
 505               	.LM61:
 506 00de 1092 0000 		sts rc5_time.1374,__zero_reg__
 507               	.L16:
 508               	/* epilogue start */
 124:main.c        **** 		}
 125:main.c        **** 	}
 126:main.c        **** }
 510               	.LM62:
 511 00e2 9F91      		pop r25
 512 00e4 8F91      		pop r24
 513 00e6 3F91      		pop r19
 514 00e8 2F91 1F90 		__gcc_isr 2
 514      1FBE 1F90 
 515 00f0 1895      		reti
 516               		__gcc_isr 0,r18
 523               	.Lscope5:
 525               		.stabd	78,0,0
 526               		.local	rc5_bit.1373
 527               		.comm	rc5_bit.1373,1,1
 529               		.local	rc5_tmp.1372
 530               		.comm	rc5_tmp.1372,2,1
 532               		.local	rc5_time.1374
 533               		.comm	rc5_time.1374,1,1
 535               		.section	.progmem.data,"a",@progbits
 538               	__c.1364:
 539 0000 4B45 593A 		.string	"KEY: "
 539      2000 
 541               		.local	rc5_data
 542               		.comm	rc5_data,2,1
 544               		.text
 546               	.Letext0:
 547               		.ident	"GCC: (GNU) 9.2.0"
 548               	.global __do_copy_data
 549               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccsISQlp.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccsISQlp.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccsISQlp.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccsISQlp.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccsISQlp.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccsISQlp.s:122    .text:0000000000000000 uart_tx
     /tmp/ccsISQlp.s:153    .text:000000000000000e uart_tx_s
     /tmp/ccsISQlp.s:200    .text:0000000000000028 uart_tx_P
     /tmp/ccsISQlp.s:254    .text.startup:0000000000000000 main
     /tmp/ccsISQlp.s:533    .bss:0000000000000004 rc5_data
     /tmp/ccsISQlp.s:538    .progmem.data:0000000000000000 __c.1364
     /tmp/ccsISQlp.s:395    .text:0000000000000044 __vector_9
                            *ABS*:0000000000000003 __gcc_isr.n_pushed.001
     /tmp/ccsISQlp.s:530    .bss:0000000000000003 rc5_time.1374
     /tmp/ccsISQlp.s:527    .bss:0000000000000001 rc5_tmp.1372
                             .bss:0000000000000000 rc5_bit.1373

UNDEFINED SYMBOLS
__itoa_ncheck
__do_copy_data
__do_clear_bss
